<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="../css/pmag.css" type="text/css" />
</head>
<body>
<div id="header_wrap">
   <h1><a href="https://www.facebook.com/groups/programmerMagazine">程式人雜誌</a> <sub> --  <a href="https://dl.dropbox.com/u/101584453/pmag/201307/htm/home.html">2013 年 7 月號</a> (開放公益出版品)</sub></h1>
</div>
<div id="content">
<div id="TOC">
<ul>
<li><a href="#verilog-2-硬體語言的基礎-作者陳鍾誠">Verilog (2) – 硬體語言的基礎 (作者：陳鍾誠)</a></li>
</ul>
</div>
<h2 id="verilog-2-硬體語言的基礎-作者陳鍾誠"><a href="#verilog-2-硬體語言的基礎-作者陳鍾誠">Verilog (2) – 硬體語言的基礎 (作者：陳鍾誠)</a></h2>
<p>在本文中、我們將介紹 Verilog 的基本語法，以便讓讀者能很快的進入 Verilog 硬體設計的領域。</p>
<h3 id="基本型態"><a href="#基本型態">基本型態</a></h3>
<p>在一般的程式語言當中，資料的最基本型態通常是「位元」(bit)，但是在 Verilog 這種「硬體描述語言」當中， 我們必須有「面向硬體」的思考方式，因此最基本的型態從「位元」轉換為「線路」(wire)。</p>
<p>一條線路的可能值，除了 0 與 1 之外，還有可能是未定值 X ，以及高阻抗 Z，如下表所示：</p>
<table>
<thead>
<tr class="header">
<th align="left">值</th>
<th align="center">意義 說</th>
<th align="left">明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="center">低電位 布</td>
<td align="left">林代數中的假值</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="center">高電位 布</td>
<td align="left">林代數中的真值</td>
</tr>
<tr class="odd">
<td align="left">Z</td>
<td align="center">高阻抗 三</td>
<td align="left">態緩衝器的輸出，高阻抗斷線</td>
</tr>
<tr class="even">
<td align="left">X</td>
<td align="center">未定值 像</td>
<td align="left">是線路未初始化之前，以及有 0,1 兩者衝突的線路值，或者是輸入為 Z 的輸出值</td>
</tr>
</tbody>
</table>
<p>其中的 0 對應到低電位、 1 對應到高電位，這是比較容易理解的部分，但是未定值 X 與高阻抗 Z 各代表甚麼意義呢？</p>
<p>對於一條沒有阻抗的線路而言，假如我們在某點對該線路輸出 1, 另一點對該線路輸出 0，那麼這條線路到底應該是 高電位還是低電位呢？</p>
<div class="figure">
<img src="../img/VerilogWireX.jpg" alt="圖、造成未定值 X 的情況" /><p class="caption">圖、造成未定值 X 的情況</p>
</div>
<p>對於這種衝突的情況，Verilog 採用 X 來代表該線路的值。</p>
<p>而高阻抗，則基本上是代表斷線，您可以想像該線路如果是「非導體」，例如「塑膠、木頭、開關開路、或者是處於高阻抗 情況的半導體」等，就會使用者種 Z 值來代表。</p>
<p>根據這樣的四種線路狀態，一個原本簡易的 AND 閘，在數位邏輯中只要用 2<em>2 的真值表就能表示了，但在 Verilog 當中則有 4</em>4 種可能的情況，如下所示：</p>
<table>
<thead>
<tr class="header">
<th align="left">AND</th>
<th align="left">0</th>
<th align="left">1</th>
<th align="left">X</th>
<th align="left">Z</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
<tr class="odd">
<td align="left">X</td>
<td align="left">0</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
<tr class="even">
<td align="left">Z</td>
<td align="left">0</td>
<td align="left">X</td>
<td align="left">X</td>
<td align="left">X</td>
</tr>
</tbody>
</table>
<p>同樣的，讀者應該可以自行寫出 OR、XOR、NOT 等閘的「真值表」。</p>
<p>在 Verilog 當中，如果我們要宣告一條線路，只要用下列語法就可以了：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="dt">wire</span> w1;</code></pre>
<p>如果我們想一次宣告很多條線路，那麼我們可以用很多個變數描述：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="dt">wire</span> w, x, y, z;</code></pre>
<p>但是如果我們想宣告一整個排線 (例如匯流排)，那我們就可以用下列的陣列語法：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="dt">wire</span> [<span class="dv">31</span>:<span class="dv">0</span>] bus;</code></pre>
<p>如果想要一次宣告很多組排線，那我們就可以用下列的陣列群語法：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="dt">wire</span> [<span class="dv">31</span>:<span class="dv">0</span>] bus [<span class="dv">0</span>:<span class="dv">3</span>];</code></pre>
<p>當然、除了線路之外，Verilog 還有可以穩定儲存位元的型態，稱為 reg (暫存器)，reg 可以用來 儲存位元，而非像線路一樣只是「一種連接方式」而已，以下是一些 reg 的宣告方式：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="dt">reg</span> w;                 <span class="co">// 宣告一位元的暫存器變數 w</span>
<span class="dt">reg</span> x, y, z;           <span class="co">// 宣告三個一位元的暫存器變數 x, y, z</span>
<span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] r1;         <span class="co">// 宣告 32 位元的暫存器 r1</span>
<span class="dt">reg</span> [<span class="dv">31</span>:<span class="dv">0</span>] R [<span class="dv">0</span>:<span class="dv">15</span>];   <span class="co">// 宣告 16 個 32 位元的暫存器群組 R[0..15]</span></code></pre>
<p>在 Verilog 中，wire 與 reg 是比較常用的基本型態，另外還有一些較不常用的基本型態， 像是 tri (三態線路)、trireg (三態暫存器)、integer (整數) 等，在此我們先不進行介紹。</p>
<h3 id="基本邏輯閘"><a href="#基本邏輯閘">基本邏輯閘</a></h3>
<p>Verilog 既然是硬體描述語言，那當然會有邏輯閘的表示法，Verilog 提供的邏輯閘有 and, nand, or, nor, xor, xnor, not 等元件，因此您可以用下列 Verilog 程式描述一個全加器：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> fulladder (<span class="dt">input</span> a, b, c_in, <span class="dt">output</span> sum, c_out);
<span class="dt">wire</span> s1, c1, c2;

<span class="dt">xor</span> g1(s1, a, b);
<span class="dt">xor</span> g2(sum, s1, c_in);
<span class="dt">and</span> g3(c1, a,b);
<span class="dt">and</span> g4(c2, s1, c_in) ;
<span class="dt">or</span> g5(c_out, c2, c1) ;

<span class="kw">endmodule</span></code></pre>
<p>上述程式所對應的電路如下圖所示：</p>
<div class="figure">
<img src="../img/FullAdder.jpg" alt="全加器電路圖" /><p class="caption">全加器電路圖</p>
</div>
<p>這些邏輯閘並不受限於兩個輸入，也可以是多個輸入的，例如以下範例中的 g 閘，就一次將三個輸入 a, b, c_in 進行 xor 運算，產生輸出 sum 的結果。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="dt">xor</span> g(sum, a, b, c_in);</code></pre>
<p>在上一期當中，我們有給出全加器的完整測試程式範例以及執行結果，該範例可以清楚的說明 Verilog 的閘級 (Gate Level) 程式之寫法，因此我們就不再重複說明了。</p>
<p>在本文當中，我們想要詳細說明的重點是，高階的暫存器轉換 (RTL) 語法。</p>
<h3 id="高階的-rtl-語法"><a href="#高階的-rtl-語法">高階的 RTL 語法</a></h3>
<p>所謂 RTL 是 Register Transfer Language 的縮寫，也就是暫存器轉換語言，這種寫法與 C, Java 等高階語言非常相似， 因此讓「程式人」也有機會透過 Verilog 設計自己的硬體。</p>
<p>舉例而言，在數位邏輯當中，多工器是一個很有用的電路，假如我們想設計一個二選一的多工器，那麼我們可以很直覺得 用以下的 RTL 寫法，去完成這樣的電路設計。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> mux(f, a, b, sel);
<span class="dt">output</span> f;
<span class="dt">input</span> a, b, sel;
<span class="dt">reg</span> f; <span class="co">// reg 型態會記住某些值，直到被某個 assign 指定改變為止</span>

<span class="kw">always</span> @(a <span class="dt">or</span> b <span class="dt">or</span> sel) <span class="co">// 當任何變數改變的時候，會執行內部區塊</span>
  <span class="kw">if</span> (sel) f = a; <span class="co">// Always 內部的區塊採用 imperative 程式語言的寫法。</span>
  <span class="kw">else</span> f = b;
<span class="kw">endmodule</span></code></pre>
<p>對於上述程式，您還可以進一步的將參數部分化簡，將型態寫入到參數中，成為以下的形式：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> mux(<span class="dt">output</span> <span class="dt">reg</span> f, <span class="dt">input</span> a, b, sel);
<span class="kw">always</span> @(a <span class="dt">or</span> b <span class="dt">or</span> sel) <span class="co">// 當任何變數改變的時候，會執行內部區塊</span>
  <span class="kw">if</span> (sel) f = a; <span class="co">// Always 內部的區塊採用 imperative 程式語言的寫法。</span>
  <span class="kw">else</span> f = b;
<span class="kw">endmodule</span></code></pre>
<p>在 verilog 當中，if, case 等陳述一定要放在 always 或 initial 的理面，always @(cond) 代表在 cond 的 條件之下要執行該區塊，例如上述的 always @(a or b or sel) 則是在 a, b, 或 sel 有改變的時後，就必須 執行裏面的動作。</p>
<p>有時我們只希望在波型的「正邊緣」或「負邊緣」時，才執行某些動作，這時候就可以用 posedge 或 negedge 這 兩個修飾詞，例如以下的程式：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">always</span> @(<span class="kw">posedge</span> clock) <span class="kw">begin</span> <span class="co">// 當 clock 時脈在正邊緣時才執行</span>
  f = a;
<span class="kw">end</span></code></pre>
<p>而 initial 則通常是在測試程式 test bench 當中使用的，在一開始初始化的時後，可以透過 initial 設定初值， 例如以下的程式：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">initial</span> <span class="kw">begin</span> <span class="co">// 當 clock 時脈在正邊緣時才執行</span>
  clock = <span class="dv">0</span>
<span class="kw">end</span></code></pre>
<p>Verilog 程式的許多地方，都可以用 #delay 指定時間延遲，例如 #50 就是延遲 50 單位的時間 (通常一單位時間 是一奈秒 ns)。舉例而言，假如我們想要每個 50 奈秒讓 clock 變化一次，那麼我們就可以用下列寫法達到目的：</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">always</span> <span class="bn">#50</span> <span class="kw">begin</span>
  clock = ~clock; <span class="co">// 將 clock 反相 (0 變 1 、1 變 0)</span>
<span class="kw">end</span></code></pre>
<p>以上的延遲也可以寫在裡面，而不是直接寫在 always 後面，例如改用以下寫法，也能得到相同的結果。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">always</span> <span class="kw">begin</span>
  <span class="bn">#50</span>; 
  clock = ~clock; <span class="co">// 將 clock 反相 (0 變 1 、1 變 0)</span>
<span class="kw">end</span></code></pre>
<h3 id="整合的範例"><a href="#整合的範例">整合的範例</a></h3>
<p>接著、讓我們用一個整合的計數器範例，來示範這些語法的實際用途，以下是我們的程式內容。</p>
<p>檔案：counter.v</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"> <span class="co">// 定義計數器模組 counter，包含重置 reset, 時脈 clock 與暫存器 count</span>
<span class="kw">module</span> counter(<span class="dt">input</span> reset, clock, <span class="dt">output</span> <span class="dt">reg</span> [<span class="dv">7</span>:<span class="dv">0</span>] count); 
  <span class="kw">always</span> @(reset)                   <span class="co">// 當 reset 有任何改變時</span>
    <span class="kw">if</span> (reset) count = <span class="dv">0</span>;           <span class="co">//   如果 reset 是 1 ，就將 count 重置為 0</span>
  <span class="kw">always</span> @(<span class="kw">posedge</span> clock) <span class="kw">begin</span>     <span class="co">// 在 clock 時脈的正邊緣時</span>
    count = count + <span class="dv">1</span>;              <span class="co">//   將 count 加 1</span>
  <span class="kw">end</span>
<span class="kw">endmodule</span>

<span class="kw">module</span> main; <span class="co">// 測試主程式開始</span>
<span class="dt">wire</span> [<span class="dv">7</span>:<span class="dv">0</span>] i; <span class="co">// i:計數器的輸出值</span>
<span class="dt">reg</span> reset, clock; <span class="co">// reset:重置訊號, clock:時脈</span>

<span class="co">// 宣告一個 counter 模組 c0、計數器的值透過線路 i 輸出，以便觀察。</span>
counter c0(reset, clock, i); 

<span class="kw">initial</span> <span class="kw">begin</span>
  <span class="dt">$display</span>(<span class="st">&quot;%4dns: reset=%d clock=%d i=%d&quot;</span>, <span class="dt">$stime</span>, reset, clock, i); <span class="co">// 印出  0ns: reset=x clock=x i=  x</span>
  <span class="bn">#10</span> reset = <span class="dv">1</span>; clock=<span class="dv">0</span>; <span class="co">// 10ns 之後，將啟動重置訊號，並將 clock 初值設為 0</span>
  <span class="dt">$display</span>(<span class="st">&quot;%4dns: reset=%d clock=%d i=%d&quot;</span>, <span class="dt">$stime</span>, reset, clock, i); <span class="co">// 印出 10ns: reset=1 clock=0 i=  x</span>
  <span class="bn">#10</span> reset = <span class="dv">0</span>;  <span class="co">// 又經過 10ns 之後，重置完畢，將 reset 歸零</span>
  <span class="dt">$display</span>(<span class="st">&quot;%4dns: reset=%d clock=%d i=%d&quot;</span>, <span class="dt">$stime</span>, reset, clock, i); <span class="co">// 印出 20ns: reset=0 clock=0 i=  0</span>
  <span class="bn">#500</span> <span class="dt">$finish</span>; <span class="co">// 再經過 500ns 之後，結束程式</span>
<span class="kw">end</span>

<span class="kw">always</span> <span class="bn">#40</span> <span class="kw">begin</span> <span class="co">// 延遲 40ns 之後，開始作下列動作</span>
  clock=~clock; <span class="co">// 將時脈反轉 (0 變 1 、1 變 0)</span>
  <span class="bn">#10</span>;          <span class="co">// 再延遲 10ns 之後</span>
  <span class="dt">$display</span>(<span class="st">&quot;%4dns: reset=%d clock=%d i=%d&quot;</span>, <span class="dt">$stime</span>, reset, clock, i); <span class="co">// 印出 reset, clock 與 i 等變數值</span>
<span class="kw">end</span>

<span class="kw">endmodule</span></code></pre>
<p>在上述程式中，<code>$display()</code> 函數可以用來顯示變數的內容，其作用就像 C 語言的 printf() 一樣。不過、 由於 Verilog 設計的是硬體，因此像 <code>$display()</code> 這樣前面有錢字 <code>$</code> 符號的指令，其實是不會被合成為電路的， 只是方便除錯時使用而已。</p>
<p>以下是我們用 icarus 軟體編譯並執行上述程式的過程與輸出結果：</p>
<pre><code>D:\Dropbox\Public\pmag\201307\code&gt;iverilog -o counter counter.v

D:\Dropbox\Public\pmag\201307\code&gt;vvp counter
   0ns: reset=x clock=x i=  x
  10ns: reset=1 clock=0 i=  x
  20ns: reset=0 clock=0 i=  0
  50ns: reset=0 clock=1 i=  1
 100ns: reset=0 clock=0 i=  1
 150ns: reset=0 clock=1 i=  2
 200ns: reset=0 clock=0 i=  2
 250ns: reset=0 clock=1 i=  3
 300ns: reset=0 clock=0 i=  3
 350ns: reset=0 clock=1 i=  4
 400ns: reset=0 clock=0 i=  4
 450ns: reset=0 clock=1 i=  5
 500ns: reset=0 clock=0 i=  5</code></pre>
<p>您可以看到，在一開始的時候以下的 initial 區塊會被執行，但由於此時 reset, clock, i 都尚未被賦值， 所以第一個 <code>$display()</code> 印出了代表未定值的 x 符號。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">initial</span> <span class="kw">begin</span>
  <span class="dt">$display</span>(<span class="st">&quot;%4dns: reset=%d clock=%d i=%d&quot;</span>, <span class="dt">$stime</span>, reset, clock, i); <span class="co">// 印出  0ns: reset=x clock=x i=  x</span>
  <span class="bn">#10</span> reset = <span class="dv">1</span>; clock=<span class="dv">0</span>; <span class="co">// 10ns 之後，將啟動重置訊號，並將 clock 初值設為 0</span>
  <span class="dt">$display</span>(<span class="st">&quot;%4dns: reset=%d clock=%d i=%d&quot;</span>, <span class="dt">$stime</span>, reset, clock, i); <span class="co">// 印出 10ns: reset=1 clock=0 i=  x</span>
  <span class="bn">#10</span> reset = <span class="dv">0</span>;  <span class="co">// 又經過 10ns 之後，重置完畢，將 reset 歸零</span>
  <span class="dt">$display</span>(<span class="st">&quot;%4dns: reset=%d clock=%d i=%d&quot;</span>, <span class="dt">$stime</span>, reset, clock, i); <span class="co">// 印出 20ns: reset=0 clock=0 i=  0</span>
  <span class="bn">#500</span> <span class="dt">$finish</span>; <span class="co">// 再經過 500ns 之後，結束程式</span>
<span class="kw">end</span></code></pre>
<p>接著 <code>#10 reset = 1; clock=0</code> 指令在延遲 10ns 後，執行 reset=1; clock=0，於是後來的 <code>$display()</code> 就印出了 <code>10ns: reset=1 clock=0 i=  x</code> 的結果。</p>
<p>但是就在 reset 被設為 1 的時候，由於 reset 的值有所改變，因此下列模組中的 <code>always @(reset)</code> 被觸發了， 於是開始執行 <code>if (reset) count = 0</code> 這個陳述，將 count 暫存器設定為 0。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> counter(<span class="dt">input</span> reset, clock, <span class="dt">output</span> <span class="dt">reg</span> [<span class="dv">7</span>:<span class="dv">0</span>] count); 
  <span class="kw">always</span> @(reset)                   <span class="co">// 當 reset 有任何改變時</span>
    <span class="kw">if</span> (reset) count = <span class="dv">0</span>;           <span class="co">//   如果 reset 是 1 ，就將 count 重置為 0</span>
  <span class="kw">always</span> @(<span class="kw">posedge</span> clock) <span class="kw">begin</span>     <span class="co">// 在 clock 時脈的正邊緣時</span>
    count = count + <span class="dv">1</span>;              <span class="co">//   將 count 加 1</span>
  <span class="kw">end</span>
<span class="kw">endmodule</span></code></pre>
<p>然後 <code>#10 reset = 0</code> 指令又在延遲 10ns 後執行了 reset = 0，之後再用 <code>$display()</code> 時，由於 count 已經 被設定為 0，所以此時印出的結果為 <code>20ns: reset=0 clock=0 i=  0</code>。</p>
<p>initial 區塊的最後一個陳述，<code>#500 $finish</code>，會在 520ns 的時候才執行，執行時 <code>$finish</code> 會將整個測試程式 結束。</p>
<p>但在程式結束之前，以下的程式會在延遲 40ns 之後，開始將 clock 反相，然後再等待 10ns 之後用 <code>$display()</code> 印出變數內容，因此整個區塊每 50ns (=40ns+10ns) 會被執行一次。</p>
<pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">always</span> <span class="bn">#40</span> <span class="kw">begin</span> <span class="co">// 延遲 40ns 之後，開始作下列動作</span>
  clock=~clock; <span class="co">// 將時脈反轉 (0 變 1 、1 變 0)</span>
  <span class="bn">#10</span>;          <span class="co">// 再延遲 10ns 之後</span>
  <span class="dt">$display</span>(<span class="st">&quot;%4dns: reset=%d clock=%d i=%d&quot;</span>, <span class="dt">$stime</span>, reset, clock, i); <span class="co">// 印出 reset, clock 與 i 等變數值</span>
<span class="kw">end</span></code></pre>
<p>所以、您才會看到像下面的輸出結果，如果仔細觀察，會發現 clock 每 50ns 變換一次，符合上述的程式邏輯，而且每當 clock 從 0 變成 1 的正邊緣，就會觸發 counter 模組，讓 count 變數加 1 ，並且透過線路 i 的輸出被我們觀察到。</p>
<pre><code>  50ns: reset=0 clock=1 i=  1
 100ns: reset=0 clock=0 i=  1
 150ns: reset=0 clock=1 i=  2
 200ns: reset=0 clock=0 i=  2
 250ns: reset=0 clock=1 i=  3
 300ns: reset=0 clock=0 i=  3</code></pre>
<p>(註：或許您有注意到上期當中我們用 <code>$monitor()</code> 來觀察全加器的輸出，<code>$display()</code> 與 <code>$monitor()</code> 的語法 幾乎一模一樣，但是 <code>$display()</code> 是顯示該時間點的變數內容，而 <code>$monitor()</code> 則會在受觀察的變數有改變時就 列印變數內容，兩者的的功能有明顯的差異)。</p>
<h3 id="結語"><a href="#結語">結語</a></h3>
<p>在本文中，我們初淺的介紹了 Verilog 的基本語法，包含基本型態、閘級語法、以及 RTL 層級的語法等， 並且在最後用一個完整的計數器範例說明 RTL 層級的程式寫法。</p>
<p>雖然這樣的說明仍然太過粗淺，不過應該可以讓讀者看出 Verilog 語言的大致樣貌，這也是本系列文章所想要 傳達的訊息，希望讀者能夠透過本文打開硬體設計之門。</p>
<h3 id="參考文獻"><a href="#參考文獻">參考文獻</a></h3>
<ul>
<li><a href="http://ccckmit.wikidot.com/ve:main">陳鍾誠的網站/免費電子書：Verilog 電路設計</a></li>
</ul>
</div>
<div id="footer">
<a href="https://www.facebook.com/groups/programmerMagazine/">程式人雜誌</a> ，採用 <a href="http://creativecommons.org/licenses/by-sa/3.0/tw/ ">創作共用：姓名標示、相同方式分享</a> 授權，歡迎加入 <a href="https://www.facebook.com/groups/programmerMagazine/">雜誌社團</a>
</div>
</body>
</html>
